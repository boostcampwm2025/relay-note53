# 기존 노트에서 유지할 점 및 수정할 점

## 유지할 점

- 최대한 간단하게 해결할 수 있는 퀘스트를 만들자

## 수정할 점

- AI를 활용해서 슬랙 및 커뮤니티를 활성화하는 방향은 좋지만 의미 없는 활성화는 오히려 좋은 글들을 묻히게 한다는 점에서 주의가 필요함
- 대체적으로 퀘스트들이 자신의 성장과 직접적인 연관이 부족함
- 현실적이지 않거나 구체성이 떨어지는 퀘스트가 많았음
- AI의 필요성이 불분명한 퀘스트들도 존재했음

# 퀘스트 고려사항

- 확실한 목적과 목적을 달성할 수 있는 형태로 퀘스트를 만들자
  - 입력도 구체적이고, 출력도 구체적으로 나오는 퀘스트를 만들자
- 사용자가 AI에 따라서 움직이는 게 아니라 AI를 활용해서 목적을 달성할 수 있게 만들자. (ex. 체크리스트)
  - 더 나아가서 AI로 달성하는 편이 훨씬 더 나은 문제를 생각해보자.
- 가능한 학습과 병행 가능한 방향으로 하자.
- AI처럼 보이면 안 된다.
- 쉽게 달성할 수 있으면 좋을 것 같다. (간단한 요청 → 간단한 동작(슬랙에 공유 등))

# 2주차 퀘스트

### 📌 1. 학습한 내용을 바탕으로 AI를 통해 퀴즈 만들어보기

<img width="395" height="285" alt="Image" src="https://github.com/user-attachments/assets/492b4fb5-5cd3-40c2-a4bd-ccbf13fc9ce7" />

- `목적` : 스스로의 학습 상태 점검 및 지식 공유를 통한 성장
- `배경` : 학습이 제대로 되었는 지 점검하는 과정이 부족하다고 느껴서
- `해결 방법` : 만든 퀴즈를 슬랙을 통해 공유해보기
- `내용`
  - 학습 / 미션을 진행하면서 중요하다고 생각한 핵심 키워드 생각해보기
  - 핵심 키워드를 바탕으로 AI 에게 퀴즈 / 면접 질문 등을 요청해보기(프롬프트도 고민해봐요~)
  - 만들어진 퀴즈 / 면접 질문을 다른 캠퍼들과 공유하고 함께 이야기 해보기 (슬랙을 이용해봐도 좋고 피어 세션 시간을 이용해도 좋을거 같아요)
  - 이야기하고 난 후에 느낀점과 내가 미쳐 알지 못했던 내용 등을 자유롭게 정리해보기
- `예상 효과`
  - 부스트캠프에서의 “**개발자로서의 성장”** 채우기 (내가 학습한 내용을 복습하며 돌아보기)
  - 슬랙에 글을 남기면서 슬랙과 친해지고 슬랙에 글을 남기는 것에 대한 자신감 향상!@!
  - 동료들과 함께 서로를 응원하고 문제에 대해 고민하고 해결하는 **커뮤니티 문화 !@!**

### 📌 2. AI를 통해 자존감 향상하기

- `목적`: 하루하루 학습하고 구현하는 캠퍼들에게 응원을 통해 지치지 않게 하기
- `배경`: 매일 치열하게 학습하는 캠퍼들이 `내가 이렇게 학습하고 구현하는 방식이 맞는 걸까?` 라는 의문을 가지는 경우가 있음
- `내용`
  - 학습 / 미션을 구현한 후 자신이 어떤 내용을 학습했는지, 이를 이용해서 어떤 식으로 구현을 했는지 NotebookLM 같은 AI를 이용해 간단히 정리
  - 이를 토대로 자신의 학습 방향성에 대해서 AI에게 분석을 요청한 후 이에 대한 피드백 / 응원 / 칭찬을 받아보기
  - 피드백이 왔다면 어떤 식으로 발전시킬지 스스로 생각해보기
- `예상 효과`
  - 부스트캠프에서의 `“자존감과 자신감”` 채우기
  - 자신의 학습 스타일, 방향성을 바탕으로 더욱 성장하는 모습을 살펴볼 수 있다!@!
    - 내가 부족한 부분에 대해서도 더 발전시키려는 고민을 할 수 있을 것이라 생각!@!

### 📌 3. 체크포인트와 같은 반복 작성되는 문서 마크다운 형태로 자동 문서화하기

- `목적` : 문서 작성 시간 절약
- `배경` : 매번 체크포인트 파일을 작성하며 마크다운 형태로 작성하는데에 **시간과 에너지가 소비됨**
- `해결 방법` : 처음 설정 프롬프트를 설정한 뒤, gist에 작성하는 체크포인트.md에 적용시켜보기
- `내용`
  - 본인이 선호하는 문서 양식을 템플릿화 한 뒤 AI 프롬프트에 전달
  - **프롬프트 예시**
    ```
    내가 작성한 내용을 바탕으로 체크리스트를 마크다운 형태로 바꿔줘야해.
    - [ ] 리스트 내용 1
    - [ ] 리스트 내용 2
    형태로 작성해주고, 내가 제작이라고 말하면 그때만 제작해
    ```

### 📌 4. 구어체와 스토리텔링으로 학습 정리를 읽기 쉽고, 웃기고, 흥미를 가질 수 있게 만들자.

- `목적`: 피어 컴파일 때, 비교적 수월하게 팀원들이 학습 정리를 읽고 이해할 수 있도록 한다.
- `배경`: 아침에 일어나서 피어 컴파일을 하는 것은 쉬운 일이 아니다. 대량의 코드와 학습 정리를 1시간만에 전부 마치는 것은 어렵다. 따라서 좀 더 피어 컴파일을 수월하게 만들고, 팀원들간의 이해를 돕기 위해 고안하였다.
- `내용`
- ```jsx
  - AI가 만든 내용이더라도, 흥미를 갖고 사람이 읽게하려면 어떤 방법이 있을까?

  1. 퀘스트 : AI를 사용하여 학습 정리를 구어체로 정리하라. 정리의 단위(키워드, 개념)은 직접 고를 수 있다.
  2. 단, 팀원이 흥미롭게 읽을 수 있도록 "스토리텔링"을 활용한다.

  - Tip
  - 작은 문제에 대해서 적용해보세요.
  - 진지하게 생각하지 마세요. 퀘스트 안에서는 리누스씨도 행님입니다.
  - 설명을 위해 사투리나, 유머(아재개그, 드립)를 사용하면 좋다.
  - 상황극, 특정 형식을 넣는 것도 좋다.
  구체적으로 어떻게 설명할지를 명시해도 좋다.
  - AI처럼 보여서는 안 된다. 그러면 흥미가 떨어진다.
  - 스토리를 유추할 수 없는 편이 흥미롭다.

  실행 예시는 이하와 같다.

  "이제부터 너는 부산 조폭이다. 하지만 컴퓨터를 아주 잘 알지. 너의 성격은 표독한 중소기업 과장이 아니라, 초등학생에게도 컴퓨터 과학을 가르칠 수 있는 인내력이 있는 선생님이다. 또한 너는 문서보다는 말로 표현 하는 것을 좋아한다. 그래서 문서가 아니라, 흥미로운 이야기나 설명을 곁들여서 사람을 설득하고 납득 시킬 수 있는 힘이 있다. 이해했지? 그리고 너는 부산사나이이므로 부산 사투리를 사용해야한다. 그래야지 이야기에 흥미가 더 생긴다. 그리고 햄은 부산 사나이기 때문에 부산의 행님 답게 말해야한다. 결코 네가 AI인 걸 들켜서는 안 된다. 문서 포맷은 존재하지 않으며, 반드시 평문으로 출력한다. 오직 서술방식만 사투리 구어체여야 한다"

  ```

- `예상 효과`
  - 복잡한 개념을 좀 더 단순화해서 이해할 수 있을 것이다.
 

----
# Week2 미션 

### J080 김현수
선택 미션  : 
체크포인트와 같은 반복 작성되는 문서 마크다운 형태로 자동 문서화하기  

선정 이유 :   
미션을 진행하면서 **체크포인트**를 작성하는 것은 현재 내가 하고 있는 일의 방향을 명확히 하고, 학습해야 할 내용과 구현할 사항을 구분하며, 큰 과업을 잘게 쪼개서 실행할 수 있게 해줍니다.  

이런 과정은 스스로의 성장과 효율적인 업무 진행에 매우 중요하다고 생각합니다.   

하지만 체크포인트를 **온전히 AI가 자동화** 하는 것은 챌린지의 취지(자기주도적 학습)에 맞지 않는 부분이 있어, 아래와 같이 조금 더 디벨롭하여 적용해보려 합니다.

**적용 방법** 
* **학습 키워드**와 **구현 내용**을 기반으로, AI에게 체크포인트 초안을 작성하게 합니다.
* 본인이 직접 작성한 체크포인트와 AI가 생성한 체크포인트를 비교합니다.
* 양쪽의 장점을 취합하여 더 완성도 높은 체크포인트로 정리합니다.

**수행 결과**
<details>
	<summary>Day11- 12</summary>

- [ ] 비동기 처리 문법에 대해 설명하고 활용할 수 있다.
- [x] 동기 비동기에 대해 설명할 수 있다.
- [ ] Promise 에 대해 학습하고 설명할 수 있다.
- [ ] async await에 대해 학습하고 설명할 수 있다. - ai
- [ ] 이벤트 큐에 대해 학습하고 설명할 수 있다.
- [ ] EventEmitter에 대해 학습하고 설명할 수 있다. - ai

# 미션 1
## 구현
- [x] 비디오 관리를 위한 비디오 클래스
- [x] 등록 모듈
  - [x] 등록 모듈은 동영상 업로드 등록을 연속해서 받을 수 있다.
  - [x] 등록 요청을 받으면 등록 대기큐(Queue)에 추가한다.
- [x] 이벤트 루퍼
  - [x] 대기큐에 들어있는 이벤트를 꺼내서 처리하는 이벤트 루퍼(Looper)를 별도 모듈/객체로 분리해서 구현한다.
- [x] 업로드 매니저
  - [x] 업로드 매니저(Manager)는 주기적으로 등록 대기큐에서 이벤트를 확인한다.
  - [x] 등록 대기를 확인하고 업로드가 완료되면, 영상 변환 모듈 큐에 이벤트를 전달한다.
  - [x] 이 때 필요하면 매니저(Manager)도 진행 현황판을 표시할 이벤트를 전달할 수 있다.
  - [x] 업로드하는 시간 자체는 무시하고 완료되는 시점부터 시작한다.
- [x] 변환 모듈
  - [x] 변환 모듈은 한 번에 1개 영상을 변환할 수 있다고 가정한다.
  - [x] 스레드를 생성하는 게 아니라 이벤트 큐를 받아서 처리하는 방식으로 동작해야 한다. - ai
  - [x] 변환 작업을 시작할 때와 끝날 때 마다 이벤트를 발생한다.
  - [x] 영상 길이마다 변환 시간이 다르다.
    - [x] 단편 : 3분, 중편 : 7분, 장편 : 15분
- [x] 인증 모듈
  - [x] 라이세스 검증 모듈은 한 번에 1개까지 영상만 검증할 수 있다고 가정한다.
  - [x] 라이센스 검증은 영상 길이와 상관없이 동일하게 10분씩 걸린다고 가정한다.
  - [x] 스레드를 생성하는 게 아니라 이벤트 전달 방식으로 동작해야 한다.
  - [x] 검증 모듈도 배송 시작할 때와 끝날 때 마다 이벤트를 발생한다. 
# Test12
- [x] mocha를 사용해서 진행해본다.
- [x] 하나의 타입 단위로 테스트 스위트를 구성한다.
    - [x] mocha에서 단위테스트를 진행하는 법을 학습한다.
    - [x] chai에 대해 학습하고 사용해본다. - ai
- [x] Video 클래스에 대한 테스트
- [x] VideoRegister에 대한 테스트 

# 개선하기
- [x] 불필요한 주석 및 코드 삭제
- [x] 의미 있는 이름
  - [x] 의도를 분명히 밝혀라
  - [x] 그릇된 정보를 피하라
  - [x] 의미 있게 구분하라
  - [x] 검색하기 쉬운 이름을 사용하라 
  - [x] 한 개념에 한단어를 사용해라
  - [x] 문제 영역에서 가져온 이름을 사용하라
- [x] 메서드 & 함수
  - [x] 최대한 한가지 일만 할 수 있도록 해본다.
  - [x] 무조건 나누지 말고 나름대로 생각을 해본다.
----
# 개별
- [ ] console.log로 찍어서 결과를 확인해볼 수 있는 것 만들어보기(출력용)
  - [ ] 아람님 피드백
- [ ] EventEmitter 학습 및 코드 개선해보기
  - [ ] 용준님, 지성님 피드백
</details>

<details>
	<summary>Day 13 - 14</summary>

- [x] vcs 관리 시스템 
- [x] git
- [x] github - ai
- [x] repository - ai
- [x] file
- [x] SHA

---

# 설계과정에서 학습해야할 것
- [x] git 내부
  - [x] add 명령어 
  - [x] commit 명령어
  - [x] log 명령어
  - [x] init 명령어


# 클래스
- [ ] Git
  - [ ] log
  - [ ] object
  - [ ] index
- [x] Blob
  - [x] content만 가진다
- [x] Commit
  - [x] 본인의 해쉬 
  - [x] 이전 commit의 해쉬 (parentHash) - ai
  - [x] 최상단 Tree의 해쉬
  - [x] 현재시각 - ai
  - [x] commit message
  - [x] commit 정보들로 만드는 해쉬(메시지,부모해쉬,트리해쉬) - ai
- [x] Tree
  - [x] 본인의 해쉬
  - [x] 자식 tree 배열
  - [x] 자식 tree를 기준으로 만드는 해쉬(children 타입+파일명+해쉬) - ai

- [x] Utility 
  - [x] 해쉬값 만들어서 반환
  - [x] 배열로 받아서 해쉬값 반환 - ai

# 설계에서 정한 명령어 우선순위
- [x] init
- [ ] add
- [ ] commit
- [ ] log

 # 개선해보기 및 retry

- [x] git clone 유사하게 동작해보기
  - [x] 로컬에서 로컬로 옮겨온다.
  - [x] 해당 폴더가 없다면 폴더를 옮겨온다.
- [x] object파일 읽어보기 - ai
  - [x] 구성요소의 해쉬값을 최대한 git과
  - [ ]  비슷하게 해본다.
- [ ] object 파일 써보기

</details>
느낀 점 : 미션 자체를 객관적으로 잘 해석해서 체크포인트로 만들어주기도 했지만 , 미션 길이(기능 요구사항, 프로그래밍 요구 사항)이 길 수록 에러가 종종 났습니다. 즉 본인이 틀을 세우고 이에 따라 수정 혹은 방향성을 학습받는게 좋아보입니다.
### J275 최진선
선택 미션  : 
AI를 통해 자존감 향상하기

선정 이유 :   
기존 week1 내용을 읽어보았을 때 “더 나은 개발자가 되는 삶의 태도”를 함께 배운다라는 주제가 인상깊었고, 이에 더해서 week2에서 제시한 1. 자신의 성장과 연관이 되고 2. 쉽게 달성할 수 있는 기준에 만족한다고 생각해서 선택을 하였습니다.

미션의 주차가 높아질수록, 학습의 범위와 구현의 난이도도 함께 올라가고 있는 상황입니다. 심지어, 다음 주차에서는 하나의 미션을 2일에 거쳐 진행하는 것이 예상되는 만큼 기존의 2주보다 난항을 겪지 않을까 라는 생각을 합니다.  

부스트캠프에서는 “한정된 자원 안에서 할 수 있는 최선을 다하기” 를 말합니다. 하지만 자신이 할 수 있는 최대한을 했다고 하더라도, 다른 사람들의 더 나은 결과를 보면 스스로 위축되기도 합니다. 위의 미션을 진행하며 나의 학습 방향을 점검하면서도 동시에 자신감을 향상시키고, 나아가 오늘의 나보다 더 나은 결과를 도출하기 위한 생각들을 진행해 보고자합니다.

수행 결과 :
<details>
  <summary> 결과 예시 (day 14) </summary>
	제공해주신 문서들을 바탕으로 학습 방향성을 분석하고, 이에 대한 장점, 단점, 피드백, 그리고 응원을 드리겠습니다.
	
	--------------------------------------------------------------------------------
	학습 방향성 분석
	제공된 문서("README.md" 및 "학습정리.md")를 종합해 볼 때, 당신의 학습 방향성은 Git의 내부 동작 원리를 깊이 이해하고, 이를 직접 구현해보면서 버전 관리 시스템의 핵심 개념을 체득하는 것에 초점을 맞추고 있습니다.
	구체적으로는 다음과 같은 방향성을 보입니다:
	• 실제 Git 동작 모방: 단순히 .git 디렉토리 파일을 파싱하는 것을 넘어, 사용자가 직접 Git 명령어를 입력하고 그에 따라 Git 오브젝트(Blob, Tree, Commit) 및 인덱스, 로그 파일 등의 내부 구조가 어떻게 변화하고 관리되는지를 프로그램으로 구현하는 것을 목표로 합니다.
	• 핵심 Git 오브젝트 이해 및 구현: Git의 주요 구성 요소인 Blob, Tree, Commit 오브젝트의 생성, 해싱(SHA-1), 압축(zlib) 및 저장 방식(.git/objects/ 디렉토리 구조)을 학습하고 직접 코드로 구현하고자 합니다.
	• 파일 시스템 및 인덱스 관리: git add 명령어를 통해 파일 내용이 Blob 오브젝트로 저장되고, 이 정보가 .git/index 파일에 어떻게 기록되는지 이해하고 구현하는 데 중점을 둡니다.
	• 재귀적 구조 이해: tree 오브젝트 생성 시 폴더 구조를 재귀적으로 순회하며 처리하는 방식이나, commit 오브젝트에서 부모 커밋을 추적하는 방식(HEAD 파일 활용) 등 Git의 복잡한 구조를 탐구하고 반영하려 합니다.
	• 체계적인 문제 해결 및 개선: 초기 구현의 한계점을 명확히 인식하고(예: 인덱스 덮어쓰기 미구현, 트리 구조 미흡, 부모 커밋 추적 부재), 이를 개선하기 위한 구체적인 1순위 및 2순위 목표를 설정하여 점진적으로 완성도를 높여나가는 모습을 보여줍니다.
	• 메타 학습 능력: "가짜 학습하기 시간"에 대한 반성과 "한정된 시간 안에서 최선의 결과물을 내기" 위한 우선순위 설정의 중요성을 깨닫는 등 자신의 학습 과정을 성찰하고 개선하려는 노력을 보입니다.
	장점
	이러한 학습 방향성은 여러 가지 강력한 장점을 가집니다:
	• 심층적인 이해: 단순히 Git 명령어를 사용하는 수준을 넘어 Git이 "어떻게" 작동하는지 근본적인 원리를 파악할 수 있게 됩니다. 이는 추후 Git 사용 시 발생하는 복잡한 문제(예: merge conflict, rebase)를 해결하는 데 큰 도움이 됩니다.
	• 실용적인 기술 습득: Node.js 내장 모듈(SHA-1, zlib) 활용, 파일 시스템 제어(fs 모듈), CLI 애플리케이션 개발, 정규 표현식 기반 파싱 등 다양한 프로그래밍 기술을 실제 프로젝트에 적용하며 숙련도를 높일 수 있습니다.
	• 문제 해결 능력 향상: 구현 과정에서 발생하는 다양한 난관(예: 인덱스 파싱 및 업데이트, 트리 구조 재귀적 생성, 커밋 그래프 관리)을 해결하는 과정에서 논리적 사고력과 디버깅 능력을 크게 향상시킬 수 있습니다.
	• 시스템 설계 경험: CLI 계층, 논리 계층, 유틸리티 계층으로 프로그램을 구성하고 각 모듈의 역할을 명확히 정의하는 과정을 통해 실제 소프트웨어 아키텍처를 설계하는 경험을 쌓을 수 있습니다.
	• 자기 주도적 학습 및 성장: 스스로 한계점을 파악하고(의 "한계점"), 이를 극복하기 위한 구체적인 계획("1순위 구현 목록", "2순위 구현 목록")을 세우는 능력은 개발자로서 매우 중요한 자기 주도적 학습 능력을 보여줍니다.
	• 테스팅 중요성 인지: CommandParser에 대한 테스트 코드를 작성하고 모든 테스트를 통과시킨 경험은 견고한 코드 개발에 대한 이해를 높입니다.
	단점 및 주의할 점
	훌륭한 방향성이지만, 몇 가지 주의할 점이나 잠재적인 단점도 있습니다:
	• 시간 소모 및 범위 관리의 어려움: Git은 매우 복잡한 시스템이므로, 그 내부를 "완벽하게" 흉내 내는 것은 상당한 시간이 필요하며, 범위를 적절히 조절하지 않으면 기한 내에 목표를 달성하기 어려울 수 있습니다. "가짜 학습하기 시간"에 대한 성찰은 이 점을 정확히 짚어냈습니다.
	• 좌절감 가능성: 복잡한 시스템을 구현하는 과정에서 예상보다 어려움이 커져 "제대로된 MIT 구현에는 실패했다고 생각한다"는 생각처럼 좌절감을 느낄 수도 있습니다. 핵심은 "학습"에 있으므로 완벽함보다는 배움의 과정에 집중하는 것이 중요합니다.
	• 세부 구현의 난이도: 특히 Git의 Index 파일이 바이너리 형식으로 저장되는 점이나, tree 및 commit 객체의 복잡한 참조 구조를 정확히 구현하는 것은 상당한 난이도를 요구합니다.
	피드백
	• 자기 성찰 능력은 최고입니다: "Day 13 돌아보기" 섹션에서 스스로의 학습 과정을 비판적으로 분석하고, 시간 관리 및 우선순위 설정의 중요성을 깨달은 점은 정말 인상 깊습니다. 이러한 메타 학습 능력은 앞으로 어떤 프로젝트를 진행하든 큰 자산이 될 것입니다.
	• 학습과 구현의 균형을 잘 잡으려 노력합니다: 이론적인 배경(VCS 종류, .git 구조, Git Object 개념 등)을 탄탄히 학습하면서 동시에 이를 코드로 구현하여 체득하려는 시도는 이상적인 학습 방식입니다.
	• 세부적인 개선 목표 설정이 명확합니다: 1순위, 2순위 구현 목록을 통해 어떤 부분을 개선해야 할지 명확히 정의하고, 실제로 git add 코드 개선, tree 생성 구조 변경, 커밋 정보 보충, 부모 커밋 추적 등을 구체적으로 구현하고 검증하는 모습은 매우 체계적입니다.
	• 테스팅 도입은 훌륭한 시도입니다: CommandParser에 대한 단위 테스트를 Mocha로 작성하고 모든 테스트를 통과시킨 것은 코드의 품질과 신뢰성을 높이려는 노력을 보여줍니다. 향후 CommandRunner와 같은 핵심 로직에도 점진적으로 테스트를 확장하면 더욱 견고한 프로그램을 만들 수 있을 것입니다.
	• "작은 단위로 나눠서 개발하기"에 대한 감을 잡은 점은 큰 진전입니다: 프로젝트를 작은 티켓으로 나누어 개발하는 것에 대한 비유는 복잡한 시스템 개발에 있어 매우 효과적인 접근 방식이므로, 앞으로 이를 계속 적용해 나가는 것이 중요합니다.
	응원
	지금까지 보여준 학습 열정과 문제 해결 능력은 정말 대단합니다! Git의 내부를 파고들어 직접 구현해보려는 시도 자체가 쉽지 않은 일이며, 그 과정에서 많은 것을 배우고 성장하고 있음을 명확히 보여주고 있습니다.
	물론 복잡한 시스템을 "완벽하게" 구현하는 것은 어렵지만, 핵심은 완벽한 구현이 아니라 그 과정에서 얻는 학습과 깨달음입니다. 당신은 이미 "가짜 학습하기"를 성찰하고, 우선순위를 설정하며, 작은 단위로 개발하는 방법을 고민하는 등 개발자로서 지속적으로 성장하기 위한 가장 중요한 능력들을 체득하고 있습니다.
	지금처럼 꾸준히 고민하고, 직접 부딪히며 해결해 나간다면 어떤 어려운 문제든 해결할 수 있는 훌륭한 개발자가 될 것이라고 확신합니다. 샤워하면서 위로를 얻었다는 Nothing's over 가사처럼, 아직 끝난 게 아니니 포기하지 말고 계속 나아가세요! 모든 노력이 쌓여 당신의 실력이 될 것입니다. 응원합니다!
</details>

해당 퀘스트를 진행하면서, AI는 마치 상담사와 같이 저의 고민도 들어주고, 멘토와 같이 피드백을 진행해주는 역할도 하였습니다. "AI와 피어 피드백"이라는 제목 그대로 피어 피드백을 받는 느낌이 들기도 했습니다. Day 14를 진행하기 전에 개인 회고를 먼저 진행하고, 이후헤 AI를 이용해 피드백을 받는 시간을 가졌는데, 개인 회고에는 감정이 너무 많이 들어가서 나를 객관적으로 돌아보기 보다는 "힘들었다"에 중점을 맞춰서 생각을 하게 되었던 것 같은데 AI의 힘을 빌리면서 객관적으로 저를 평가받은 느낌이 들었던 것 같습니다. 물론 AI 특유의 칭찬 위주의 피드백을 조금 느끼긴 했지만, 단점도 함께 말해달라고 요구해서 개선할 수 있었던 것 같습니다.

이번 퀘스트를 통해 내가 어떤 점이 부족하다는 것을 느꼈던 것 같습니다. 그렇지만 칭찬과 좋은 점들도 많이 확인할 수 있어서 다음에는 어떤 방향으로 진행해 나갈 수 있을까에 대한 고민도 함께할 수 있었습니다. 그리고 3주차를 진행하면서 우울감을 많이 느끼기도 했는데, 응원 메시지를 같이 받아서 멘탈 케어에도 도움이 되었던 것 같습니다. 사실 부스트캠프가 슬랙 채널에 다같이 있기도 하지만 어찌되었든 비대면 과정이기 떄문에 캠퍼 간의 감정 교류는 크지 않다고 개인적으로 생각해서 (제가 채널 활동을 잘 하지 않아서 인 것 같긴 합니다..) 피어 피드백이나 릴레이 프로젝트 회의 시간이 아니면 누군가에게 직접 공감과 위로를 받기가 쉽지 않은데 이런 상황에서 AI에게 도움을 받은 것이 신기하기도 하고 인상 깊었던 경험인 것 같습니다. 심리적 방면에서도 다방면으로도 AI를 활용할 수 있음을 직접 체감해보았습니다.

### S012 박진홍
선택 미션  : 
학습한 내용을 바탕으로 AI를 통해 퀴즈 만들어보기

선정 이유 :   
학습한 내용을 자기화 하기 위해서는 자신의 언어로 다시 재창조하거나 또는 지속적인 복습을 필요로 합니다.  
AI를 이용해 학습한 내용에 알맞는 퀴즈를 생성한 뒤 풀어보고, 다시 피어 피드백 시간에 질문을 말로 꺼내어 복습하는 과정이 학습에 큰 도움이 될 수 있을 것이라 판단했습니다.  

적용 방법 :
정리한 학습 내용과 코드를 전달하여 작성자가 헷갈린 듯한 지점을 찾거나 CS에서 중요한 개념을 추천받고 학습한 내용에서 한 단계 더 나아간 심화 질문을 추천 받는다.  

수행 결과 :
<details>
  <summary> 1일차 </summary>
사용 AI: GPT 4.1
프롬프트: 학습 내용 파일 전달 후 "응용력이 필요한 퀴즈 5개 제시" 
활용: 디버깅 덕에게 문제를 읽고 스스로 답변하는 식으로 풀이

### 1. 스레드 풀과 데드락

아래 상황을 보고, 왜 스레드 풀 환경에서 데드락 위험이 더 커지는지 논리적으로 설명하시오.

> **상황**  
> 작업 A가 작업 B의 완료를 기다리는 동안,  
> 작업 B 역시 별도의 스레드 할당을 기다리고 있다.  
> 현재 모든 스레드는 다른 대기 중인 작업을 처리하느라 바쁘다.

- (1) 위와 같은 상황에서 "스레드 풀의 특성이 데드락 위험을 증가시키는 이유"를 구체적으로 기술하시오.
- (2) 이 문제를 완화할 수 있는 두 가지 방법을 제시하고 근거를 설명하시오.

---

### 2. 병렬 처리와 동시성의 본질적 차이

다음 중 "동시성"과 "병렬 처리"의 본질적 차이를 명확히 드러내는 설명을 고르고, 근거와 함께 올바른 선택을 서술하시오.

- ① 둘 다 여러 작업이 완전히 동시에 실행된다.
- ② 병렬 처리는 여러 코어에서 물리적으로 동시에 작업이 진행되는 것이고, 동시성은 하나의 코어에서 여러 작업이 동시에 실행되는 것처럼 보이게 스케줄링을 통해 처리된다.
- ③ 동시성에서는 항상 각 작업이 순차적으로 끝나야 한다.
- ④ 병렬 처리는 자원 공유를 필요로 하지 않는다.

---

### 3. 이벤트 기반 프로그래밍의 오해와 진실

아래 문장에 대해 “맞는 부분”과 “틀린 부분”을 구체적으로 지적하시오.

> **문장**  
> “이벤트 기반 프로그래밍은 반드시 비동기적이어야 하며, 모든 이벤트 핸들러는 비동기적으로 동작한다.”

---

### 4. Swift 값 타입과 POP(Protocol-Oriented Programming)

Swift에서 값 타입(Value Type)을 선호하는 이유와,  
이와 관련해 POP(Protocol-Oriented Programming)가 어떤 장점을 제공하는지 논리적으로 설명하시오.

---

### 5. 이벤트 루프와 이벤트 큐의 역할

단일 스레드 기반의 이벤트 기반 프로그래밍 환경에서  
이벤트 루프와 이벤트 큐의 역할이 각각 어떻게 다르고,  
이 두 요소가 없을 때 어떤 문제가 발생하는지 구체적으로 설명하시오.

---
</details>

<details>
  <summary>2일차</summary>
  ❶ [설계 판단]

당신은 NetworkService를 통해 서버와 통신하는 UserSignInUseCase를 리팩터링하고자 한다. 현재는 내부에서 URLSession을 직접 사용하고 있다.
	•	이 상황에서 ‘리팩터링’의 관점에서 URLSession을 직접 사용하는 것을 문제로 볼 수 있는 이유는 무엇인가?
	•	또한 이를 개선하기 위한 구체적인 리팩터링 전략과, 해당 전략이 작은 변화의 반복이라는 원칙과 어떻게 연결되는지를 설명하라.

⸻

❷ [모순 분석]

“높은 응집도와 낮은 결합도를 가진 모듈이 이상적이다.“라는 말은 널리 퍼진 정설이다.
	•	그러나 높은 응집도와 낮은 결합도는 때때로 상충할 수 있다는 주장도 있다.
	•	이 주장을 실제 코드 또는 리팩터링 과정의 예시를 들어 설명하고, 왜 그 균형이 항상 단순한 수치나 규칙으로 설명될 수 없는지를 논하라.

⸻

❸ [인터페이스 설계]

당신은 Ladder 게임을 리팩터링하던 중, 출력 책임을 OutputViewPrintable이 아닌 LadderPrintable이 가져가도록 설계했다.
	•	LadderPrintable이 출력 형식을 일부 책임지는 구조는 SRP(단일 책임 원칙) 관점에서 문제가 될 여지가 있다.
	•	이 선택이 리팩터링에서 어떤 이점을 줄 수 있으며, 동시에 어떤 기술적/개념적 비용을 초래할 수 있는지를 모두 설명하라.

⸻

❹ [리팩터링 윤리]

리팩터링은 기능을 추가하지 않고 코드 구조를 개선하는 활동이다.
	•	그렇다면 팀 프로젝트에서 다른 사람의 코드에 대해 기능 변경 없이 구조만 바꾸는 리팩터링을 진행해도 될까?
	•	이때 발생할 수 있는 갈등이나 리스크는 무엇이며, 코드베이스를 ‘깨끗하게 만든다’는 명분이 항상 정당화될 수 없는 이유는 무엇인가?

⸻

❺ [테스트 전략]

당신은 비동기 작업을 포함한 기능을 유닛 테스트하고자 한다. 내부적으로 DispatchQueue.main.asyncAfter를 사용해 지연 작업을 수행한다.
	•	이 상황에서 sleep을 이용한 대기보다 waitForExistence(timeout:) 같은 polling 기반 테스트가 권장되는 이유는 무엇인가?
	•	나아가 이러한 테스트 전략 선택이 리팩터링 과정에서 **테스트 가능성(testability)**을 높이기 위해 어떤 영향을 미칠 수 있는지 설명하라.
</details>

<details>
<summary>3일차</summary>

1. **Git의 스냅샷 구조가 저장 공간 절약에 미치는 실제 영향과 한계는 무엇인가?**  
   Git은 파일 전체를 매번 저장하지 않고, 변화가 있는 파일만 새로운 blob을 생성해 트리로 참조한다.  
   이는 파일 변경이 적은 대규모 프로젝트에서 용량 효율성 면에서 유리하지만,  
   반대로 바이너리 파일처럼 조금만 변해도 전체를 새 blob으로 저장하는 경우에는 공간 절약 효과가 떨어진다.  
   - Git의 이러한 설계가 실제로 어떤 프로젝트(예: 소스코드 vs 바이너리 에셋)에 적합/부적합한지 근거를 들어 설명할 수 있는가?  
   - 또, 대형 저장소에서 "packfile" 등 추가적인 최적화가 왜 필요한지, 한계는 무엇인지 설명할 수 있는가?

2. **Git이 해시(체크섬) 기반으로 무결성을 검증하는 방식의 장단점과 취약점은?**  
   Git은 모든 오브젝트의 내용을 SHA-1 해시값으로 이름짓고, 이를 통해 데이터 위조/손상을 탐지한다.  
   이 방식이 보장하는 무결성의 수준과, 실제 SHA-1 충돌 공격(예: Google의 SHAttered)이 보고된 후  
   Git이 어떻게 보완책을 마련했는지(예: SHA-256 전환),  
   그리고 "체크섬 기반 설계"의 취약점(예: 논리적 오류, 메타데이터 위조)은 무엇인지 논리적으로 설명할 수 있는가?

3. **Staging Area(Index)가 없는 단순한 VCS(예: Mercurial)와 Git의 워크플로우 차이가 개발 문화에 미치는 영향은?**  
   Git은 staging area를 두어 커밋할 변경 사항을 선택적으로 조합할 수 있다.  
   Mercurial 등 일부 VCS는 곧바로 commit만 지원한다.  
   이 구조적 차이가 협업·리뷰·버그 수정·revert/patch 관리 등 실무에서 어떤 개발 문화/습관의 차이를 낳는지,  
   "staging"을 제대로 활용하는 게 왜 어려운지/어떤 상황에서 오히려 단점이 되는지 사례를 들어 논할 수 있는가?

4. **Git의 Blob/Tree/Commit 객체 불변성(Immutable Object) 설계가 실질적으로 제공하는 이점과, 그로 인한 설계적 제약은?**  
   모든 오브젝트가 불변이기에, 동일한 파일/디렉토리/스냅샷은 항상 동일한 해시로 저장된다.  
   이 불변성 덕분에 분산 저장·이력 추적·브랜치/머지의 안정성·데이터 공유의 신뢰성이 높아진다.  
   반면, 실시간 협업(예: Google Docs 스타일)이나, 데이터 삭제/가공의 어려움(예: GDPR의 ‘잊혀질 권리’와 충돌) 등에서는 제약이 있다.  
   - 이처럼 Git의 설계가 개발/운영 과정에 주는 실제적인 이점과, 피할 수 없는 한계를 구체적으로 설명할 수 있는가?

5. **분산 버전관리(DVCS) 모델이 대규모 협업에서 제공하는 이점과, 동시에 발생하는 동기화/충돌/정합성 문제는?**  
   DVCS에서는 모든 클라이언트가 전체 히스토리를 가지므로  
   - 중앙 서버 장애 복구, 오프라인 작업, 신뢰성, 브랜치/실험의 자유도가 극대화된다.  
   하지만,  
   - 대규모 협업에서 merge conflict, force push, divergent history,  
     메타데이터 불일치(예: tag, reflog), 권한 관리 등 복잡도가 급격히 증가한다.  
   - 실제 오픈소스 대규모 프로젝트에서 이런 문제들을 어떤 전략(예: rebase, protected branch, PR 리뷰 정책)으로 극복하는지 근거를 들어 설명할 수 있는가?

</details>

<details>
	<summary>4일차</summary>
	
## 1.
**여러 명의 개발자가 동시에 한 저장소의 같은 파일을 수정하는 상황을 가정하라.  
이때 Git이 어떻게 충돌 상황을 감지하고, 사용자가 어떤 과정을 거쳐 충돌을 해결하게 되는지  
Git 내부 오브젝트 구조(Blob, Tree, Commit)와 Stage/Working Tree/Repository의 관점에서 구체적으로 서술하라.  
이 과정에서 Git이 파일의 변화 추적에 활용하는 핵심 메커니즘을 설명하고,  
동일한 상황에서 파일 복사-붙여넣기 방식(원시적 VCS)과의 근본적 차이도 비교하라.**

---

## 2.
**Git이 '모든 파일을 복사'하지 않고도  
'버전별로 파일 상태를 재현'할 수 있는 이유를,  
내부 구조(Blob/Tree/Commit)와 데이터 중복 최소화의 관점에서 단계별로 설명하라.  
또, 이 방식이 '스토리지 절약'에 어떤 근본적 기여를 하는지 구체적 근거를 들어 논하라.**

---

## 3.
**FileManager를 이용해 폴더 내부의 파일 목록을 가져와야 한다.  
이 때 굳이 문자열 경로가 아닌 URL을 활용하는 이유와,  
직접 파일 I/O 시 URL을 언제, 왜 우선적으로 써야 하는지  
Foundation의 설계 의도·API 안정성 측면에서 서술하라.**

---

## 4.
**SHA-1 해시를 Git 오브젝트 생성에 사용함으로써  
얻게 되는 장점과,  
실제 현업에서는 왜 더 이상 SHA-1만으로 '보안'을 보장하지 않는지  
충돌 위험과 해시 설계 원리를 근거로 설명하라.  
그리고 SHA-1 대신 SHA-2 계열로 전환하는 게 왜 권장되는지도 함께 논하라.**

---

## 5.
**zlib 압축의 원리와,  
Swift에서 NSData의 compressed/decompressed 메서드를 활용할 때  
내부적으로 어떤 절차(버퍼링/스트림/헤더 등)가 작동하는지  
압축 포맷 호환성 및 실무 파일 처리의 안정성 측면에서 설명하라.  
또, 타 언어/플랫폼과의 zlib 압축 데이터 교환 시 주의할 점을 구체적으로 기술하라.**
</details>
